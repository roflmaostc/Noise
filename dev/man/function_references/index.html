<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function References · Noise.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Noise.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Noise.jl</a></li><li><a class="tocitem" href="../additive_white_gaussian/">Additive White Gaussian</a></li><li><a class="tocitem" href="../mult_gauss/">Multiplicative White Gaussian</a></li><li><a class="tocitem" href="../salt_pepper/">Salt and Pepper</a></li><li><a class="tocitem" href="../poisson/">Poisson</a></li><li><a class="tocitem" href="../quantization/">Quantization</a></li><li class="is-active"><a class="tocitem" href>Function References</a><ul class="internal"><li><a class="tocitem" href="#Additive-White"><span>Additive White</span></a></li><li><a class="tocitem" href="#Salt-and-Pepper"><span>Salt and Pepper</span></a></li><li><a class="tocitem" href="#Poisson"><span>Poisson</span></a></li><li><a class="tocitem" href="#Quantization"><span>Quantization</span></a></li><li><a class="tocitem" href="#Multiplicative-Gaussian-Noise"><span>Multiplicative Gaussian Noise</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Function References</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function References</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/roflmaostc/Noise.jl/blob/master/docs/src/man/function_references.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Function-References"><a class="docs-heading-anchor" href="#Function-References">Function References</a><a id="Function-References-1"></a><a class="docs-heading-anchor-permalink" href="#Function-References" title="Permalink"></a></h1><h2 id="Additive-White"><a class="docs-heading-anchor" href="#Additive-White">Additive White</a><a id="Additive-White-1"></a><a class="docs-heading-anchor-permalink" href="#Additive-White" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Noise.add_gauss" href="#Noise.add_gauss"><code>Noise.add_gauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_gauss(X; clip=false[, σ=0.1, μ=0.0])</code></pre><p>Returns the array <code>X</code> with gauss noise (standard deviation <code>σ</code> and mean <code>μ</code>)  added.  <code>σ</code> and <code>μ</code> are optional arguments representing standard deviation and mean of gauss. If keyword argument <code>clip</code> is provided the values are clipped to be in [0, 1]. If <code>X</code> is a RGB{Normed} or Gray{Normed} image, then the values will be automatically clipped and the keyword  <code>clip</code> is meaningless.</p><p>If <code>X&lt;:Complex</code>, <code>μ</code> and <code>σ</code> are applied to the imaginary in the same way as for the real part. If you want to have different behaviour for real and imaginary part, simply choose <code>μ</code> or <code>σ</code> complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/roflmaostc/Noise.jl/blob/3bf28de0ee223605ca69d5f0b5681d1eddcd881c/src/white_noise_additive.jl#L23-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Noise.add_gauss_chn" href="#Noise.add_gauss_chn"><code>Noise.add_gauss_chn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">add_gauss_chn(X; clip=false[, σ=0.1, μ=0.0])</code></pre><p>Returns the RGB image <code>X</code> with gauss noise (standard deviation <code>σ</code> and mean <code>μ</code>)  added pixelwise. However, every channel of one pixel receives the same amount of noise. The noise therefore acts roughly as intensity - but not color - changing noise. If keyword argument <code>clip</code> is provided the values are clipped to be in [0, 1]. <code>σ</code> and <code>μ</code> are optional arguments representing standard deviation and mean of gauss.</p><p>If <code>X&lt;:Complex</code>, <code>μ</code> and <code>σ</code> are applied to the imaginary in the same way as for the real part. If you want to have different behaviour for real and imaginary part, simply choose <code>μ</code> or <code>σ</code> complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/roflmaostc/Noise.jl/blob/3bf28de0ee223605ca69d5f0b5681d1eddcd881c/src/white_noise_additive.jl#L44-L56">source</a></section></article><h2 id="Salt-and-Pepper"><a class="docs-heading-anchor" href="#Salt-and-Pepper">Salt and Pepper</a><a id="Salt-and-Pepper-1"></a><a class="docs-heading-anchor-permalink" href="#Salt-and-Pepper" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Noise.salt_pepper" href="#Noise.salt_pepper"><code>Noise.salt_pepper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">salt_pepper(X; salt_prob=0.5, salt=1.0, pepper=0.0[, prob=0.1])</code></pre><p>Returns array <code>X</code> affected by salt and pepper noise. <code>X</code> can be an array or an RGB or Gray image <code>prob</code> is a optional argument for the probability that a pixel will be affected by the noise. <code>salt_prob</code> is a keyword argument representing the probability for salt noise.  The probability for pepper noise is therefore 1-<code>salt_prob</code>. <code>salt</code> is a keyword argument for specifying the value of salt noise. <code>pepper</code> is a keyword argument for specifying the value of pepper noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/roflmaostc/Noise.jl/blob/3bf28de0ee223605ca69d5f0b5681d1eddcd881c/src/salt_pepper.jl#L32-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Noise.salt_pepper_chn" href="#Noise.salt_pepper_chn"><code>Noise.salt_pepper_chn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">salt_pepper_chn(X; salt_prob=0.5, salt=1.0, pepper=0.0[, prob=0.1])</code></pre><p>Returns a RGB Image <code>X</code> affected by salt and pepper noise. When a salt or pepper occurs, it is applied to all channels of the RGB making a real salt and pepper on the whole image. <code>prob</code> is a optional argument for the probability that a pixel will be affected by the noise. <code>salt_prob</code> is a keyword argument representing the probability for salt noise.  The probability for pepper noise is therefore 1-<code>salt_prob</code>. <code>salt</code> is a keyword argument for specifying the value of salt noise. <code>pepper</code> is a keyword argument for specifying the value of pepper noise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/roflmaostc/Noise.jl/blob/3bf28de0ee223605ca69d5f0b5681d1eddcd881c/src/salt_pepper.jl#L55-L66">source</a></section></article><h2 id="Poisson"><a class="docs-heading-anchor" href="#Poisson">Poisson</a><a id="Poisson-1"></a><a class="docs-heading-anchor-permalink" href="#Poisson" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Noise.poisson" href="#Noise.poisson"><code>Noise.poisson</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">poisson(X; scaling=nothing, clip=false)</code></pre><p>Returns the array <code>X</code> affected by Poisson noise.  At every position the Poisson noise affects the intensity individually  and the values at the positions represent the expected value of the Poisson Distribution.  Since Poisson Noise due to discrete events you should provide the optional argument <code>scaling</code>. This <code>scaling</code> connects the highest value of the array with the discrete number of events. The highest value will be then scaled and the poisson noise is applied Afterwards we scale the whole array back so that the initial intensity is preserved but with applied Poisson noise. <code>clip</code> is a keyword argument. If given, it clips the values to [0, 1]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/roflmaostc/Noise.jl/blob/3bf28de0ee223605ca69d5f0b5681d1eddcd881c/src/poisson.jl#L26-L40">source</a></section></article><h2 id="Quantization"><a class="docs-heading-anchor" href="#Quantization">Quantization</a><a id="Quantization-1"></a><a class="docs-heading-anchor-permalink" href="#Quantization" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Noise.quantization" href="#Noise.quantization"><code>Noise.quantization</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">quantization(X, levels; minv=0, maxv=1)</code></pre><p>Returns array <code>X</code> discretized to <code>levels</code> different values. Therefore the array is discretized. <code>levels</code> describes how many different value steps the resulting image has. <code>minv=0</code> and <code>maxv</code> indicate the minimum and maximum possible values of the images. In RGB and Gray images this is usually 0 and 1. There is also <code>quantization!</code> available.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/roflmaostc/Noise.jl/blob/3bf28de0ee223605ca69d5f0b5681d1eddcd881c/src/quantization.jl#L19-L28">source</a></section></article><h2 id="Multiplicative-Gaussian-Noise"><a class="docs-heading-anchor" href="#Multiplicative-Gaussian-Noise">Multiplicative Gaussian Noise</a><a id="Multiplicative-Gaussian-Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Multiplicative-Gaussian-Noise" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Noise.mult_gauss" href="#Noise.mult_gauss"><code>Noise.mult_gauss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mult_gauss(X; clip=false[, σ=0.1, μ=1])</code></pre><p>Returns the array <code>X</code> with the array value multiplied with a gauss distribution (standard deviation <code>σ</code> and mean <code>μ</code>) .  <code>σ</code> and <code>μ</code> are optional arguments representing standard deviation and mean of gauss. If keyword argument <code>clip</code> is provided the values are clipped to be in [0, 1]. If <code>X</code> is a RGB{Normed} or Gray{Normed} image, then the values will be automatically clipped and the keyword  <code>clip</code> is meaningless.</p><p>If <code>X&lt;:Complex</code>, <code>μ</code> and <code>σ</code> are applied to the imaginary in the same way as for the real part. If you want to have different behaviour for real and imaginary part, simply choose <code>μ</code> or <code>σ</code> complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/roflmaostc/Noise.jl/blob/3bf28de0ee223605ca69d5f0b5681d1eddcd881c/src/multiplicative_noise.jl#L13-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Noise.mult_gauss_chn" href="#Noise.mult_gauss_chn"><code>Noise.mult_gauss_chn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">mult_gauss_chn(X; clip=false[, σ=0.1, μ=0.0])</code></pre><p>Returns the RGB image <code>X</code> with the values of the pixel multiplied with a gauss distribution (standard deviation <code>σ</code> and mean <code>μ</code>) pixelwise.  However, every channel of one pixel receives the same amount of noise. The noise therefore acts roughly as intensity - but not color - changing noise. If keyword argument <code>clip</code> is provided the values are clipped to be in [0, 1]. <code>σ</code> and <code>μ</code> are optional arguments representing standard deviation and mean of gauss.</p><p>If <code>X&lt;:Complex</code>, <code>μ</code> and <code>σ</code> are applied to the imaginary in the same way as for the real part. If you want to have different behaviour for real and imaginary part, simply choose <code>μ</code> or <code>σ</code> complex.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/roflmaostc/Noise.jl/blob/3bf28de0ee223605ca69d5f0b5681d1eddcd881c/src/multiplicative_noise.jl#L32-L45">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quantization/">« Quantization</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 7 February 2024 13:53">Wednesday 7 February 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
